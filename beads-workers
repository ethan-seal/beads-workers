#!/run/current-system/sw/bin/bash
# Beads Workers - Concurrent task processing system for beads
# Usage: beads-workers <command> [options]

set -e

VERSION="1.0.0"
WORKER_LOG_DIR="${BEADS_WORKERS_LOG_DIR:-/tmp}"
NUM_WORKERS="${BEADS_WORKERS_COUNT:-10}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}â„¹${NC} $1"
}

log_success() {
    echo -e "${GREEN}âœ“${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
}

log_error() {
    echo -e "${RED}âœ—${NC} $1" >&2
}

# Check if we're in a beads project
check_beads_project() {
    if [ ! -d ".beads" ]; then
        log_error "Not in a beads project directory (no .beads/ found)"
        log_info "Run this command from the root of a beads project"
        exit 1
    fi
}

# Ensure no-daemon mode is enabled for performance
ensure_no_daemon() {
    if [ ! -f ".beads/config.yaml" ]; then
        log_warning "No .beads/config.yaml found, skipping performance optimization"
        return
    fi

    if grep -q "^no-daemon: true" .beads/config.yaml 2>/dev/null; then
        return
    fi

    log_info "Enabling no-daemon mode for 192x performance boost..."

    if grep -q "^# no-daemon:" .beads/config.yaml 2>/dev/null; then
        sed -i 's/^# no-daemon:.*$/no-daemon: true/' .beads/config.yaml
    elif grep -q "^no-daemon: false" .beads/config.yaml 2>/dev/null; then
        sed -i 's/^no-daemon: false$/no-daemon: true/' .beads/config.yaml
    else
        echo "" >> .beads/config.yaml
        echo "# Added by beads-workers for performance" >> .beads/config.yaml
        echo "no-daemon: true" >> .beads/config.yaml
    fi

    log_success "Enabled no-daemon mode in .beads/config.yaml"
}

# Get worker PIDs
get_worker_pids() {
    pgrep -f "beads-workers worker-process" 2>/dev/null || true
}

# Count running workers
count_workers() {
    get_worker_pids | wc -l
}

# Worker process
worker_process() {
    local worker_id=$1
    local log_file="$WORKER_LOG_DIR/beads_worker_${worker_id}.log"

    exec > >(tee -a "$log_file") 2>&1

    log() {
        echo "[Worker $worker_id $(date '+%Y-%m-%d %H:%M:%S')] $1"
    }

    log "Starting worker in $(pwd)"

    # Stagger startup
    local startup_delay=$((worker_id * 2))
    log "Staggering startup by ${startup_delay}s..."
    sleep "$startup_delay"

    while true; do
        # Get ready issues
        ready_output=$(bd ready 2>&1)

        if echo "$ready_output" | grep -q "no issues ready"; then
            log "No issues available, waiting 30s..."
            sleep 30
            continue
        fi

        # Extract issue IDs
        mapfile -t all_issue_ids < <(echo "$ready_output" | grep -oP '\w+-\w+-[a-z0-9]{3}' || true)

        if [ ${#all_issue_ids[@]} -eq 0 ]; then
            log "Could not parse issue IDs, waiting 30s..."
            sleep 30
            continue
        fi

        # Filter out epics (epics are containers, not work items)
        issue_ids=()
        for candidate_id in "${all_issue_ids[@]}"; do
            issue_type=$(bd show "$candidate_id" --json 2>/dev/null | jq -r '.[0].type // "unknown"')
            if [ "$issue_type" != "epic" ]; then
                issue_ids+=("$candidate_id")
            else
                log "Filtering out epic $candidate_id from available work"
            fi
        done

        # Check if any non-epic issues are available
        if [ ${#issue_ids[@]} -eq 0 ]; then
            log "Only epics available (no tasks/bugs/features ready), waiting 30s..."
            sleep 30
            continue
        fi

        # Pick random issue from non-epic issues
        random_index=$((RANDOM % ${#issue_ids[@]}))
        issue_id="${issue_ids[$random_index]}"

        log "Attempting to claim issue: $issue_id"

        # Claim the issue
        if ! bd update "$issue_id" --status=in_progress 2>&1; then
            log "Failed to claim $issue_id (race condition), retrying..."
            sleep 2
            continue
        fi

        log "Issue details:"
        bd show "$issue_id" 2>&1

        # Simulate work (replace with actual work)
        work_time=$((10 + RANDOM % 20))
        log "Working on $issue_id for ${work_time}s..."
        sleep "$work_time"

        # Close the issue
        log "Closing issue: $issue_id"
        bd close "$issue_id" --reason="Completed by worker $worker_id" 2>&1

        log "Issue $issue_id completed, looking for next task..."

        # Random delay to desynchronize
        cycle_delay=$((2 + RANDOM % 4))
        log "Waiting ${cycle_delay}s before next cycle..."
        sleep "$cycle_delay"
    done
}

# Command: start
cmd_start() {
    check_beads_project
    ensure_no_daemon

    local current_count=$(count_workers)
    if [ "$current_count" -gt 0 ]; then
        log_warning "$current_count workers already running"
        log_info "Use 'beads-workers stop' first, or 'beads-workers status' to see them"
        exit 1
    fi

    log_info "Starting $NUM_WORKERS workers..."

    # Clean old logs
    rm -f "$WORKER_LOG_DIR"/beads_worker_*.log

    # Launch workers
    for i in $(seq 1 "$NUM_WORKERS"); do
        (
            # Run worker process in background
            "$0" worker-process "$i" &
        ) &
    done

    sleep 2

    local started=$(count_workers)
    if [ "$started" -eq "$NUM_WORKERS" ]; then
        log_success "Started $NUM_WORKERS workers"
        log_info "Use 'beads-workers watch' to monitor progress"
        log_info "Use 'beads-workers stop' to stop all workers"
    else
        log_warning "Started $started workers (expected $NUM_WORKERS)"
    fi
}

# Command: stop
cmd_stop() {
    local pids=$(get_worker_pids)

    if [ -z "$pids" ]; then
        log_info "No workers running"
        return
    fi

    local count=$(echo "$pids" | wc -w)
    log_info "Stopping $count workers..."

    echo "$pids" | xargs kill 2>/dev/null || true
    sleep 2

    # Force kill if still running
    pids=$(get_worker_pids)
    if [ -n "$pids" ]; then
        log_warning "Force killing remaining workers..."
        echo "$pids" | xargs kill -9 2>/dev/null || true
        sleep 1
    fi

    local remaining=$(count_workers)
    if [ "$remaining" -eq 0 ]; then
        log_success "All workers stopped"
    else
        log_error "$remaining workers still running"
        exit 1
    fi

    # Show final stats if in beads project
    if [ -d ".beads" ]; then
        echo ""
        log_info "Final stats:"
        bd stats 2>/dev/null || true
    fi
}

# Command: restart
cmd_restart() {
    log_info "Restarting workers..."
    cmd_stop
    sleep 1
    cmd_start
}

# Command: status
cmd_status() {
    check_beads_project

    local worker_count=$(count_workers)

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ðŸ“Š Beads Workers Status"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    echo "Active Workers: $worker_count/$NUM_WORKERS"

    if [ "$worker_count" -gt 0 ]; then
        echo ""
        echo "Worker PIDs:"
        get_worker_pids | while read -r pid; do
            echo "  $pid"
        done
    fi

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ðŸ“Š Project Stats"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    bd stats 2>/dev/null || echo "Could not fetch stats"

    if [ "$worker_count" -gt 0 ]; then
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸ”„ Recent Worker Activity"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

        for i in $(seq 1 "$NUM_WORKERS"); do
            log_file="$WORKER_LOG_DIR/beads_worker_$i.log"
            if [ -f "$log_file" ]; then
                echo ""
                echo "Worker $i:"
                tail -3 "$log_file" 2>/dev/null | sed 's/^/  /' || echo "  (no log)"
            fi
        done
    fi
}

# Command: watch
cmd_watch() {
    check_beads_project

    local refresh_interval=2

    # Terminal control sequences
    local cursor_home="\033[H"
    local clear_screen="\033[2J"
    local hide_cursor="\033[?25l"
    local show_cursor="\033[?25h"

    show_dashboard() {
        local output=""

        output+="â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
        output+="â•‘                    BEADS WORKER LIVE DASHBOARD                             â•‘\n"
        output+="â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
        output+="\n"
        output+="ðŸ• Last update: $(date '+%Y-%m-%d %H:%M:%S')\n"
        output+="\n"

        # Project stats
        output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        output+="ðŸ“Š PROJECT STATS\n"
        output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

        local stats_output=$(bd stats 2>/dev/null)
        local total=$(echo "$stats_output" | grep "Total Issues:" | awk '{print $3}')
        local open=$(echo "$stats_output" | grep "Open:" | awk '{print $2}')
        local closed=$(echo "$stats_output" | grep "Closed:" | awk '{print $2}')
        local blocked=$(echo "$stats_output" | grep "Blocked:" | awk '{print $2}')
        local ready=$(echo "$stats_output" | grep "Ready:" | awk '{print $2}')

        # Count actually working
        local actually_working=0
        for i in $(seq 1 "$NUM_WORKERS"); do
            local log_file="$WORKER_LOG_DIR/beads_worker_$i.log"
            if [ -f "$log_file" ]; then
                if tail -1 "$log_file" 2>/dev/null | grep -q "Working on"; then
                    actually_working=$((actually_working + 1))
                fi
            fi
        done

        output+=$(printf "Total: %-4s â”‚ Open: %-4s â”‚ Closed: %-4s â”‚ Ready: %-4s â”‚ Blocked: %-4s\n" "$total" "$open" "$closed" "$ready" "$blocked")
        output+="\n"
        output+=$(printf "ðŸ”¥ IN PROGRESS: %s workers actively working on tasks\n" "$actually_working")
        output+="\n"

        # Workers
        local worker_count=$(count_workers)

        if [ "$worker_count" -eq 0 ]; then
            output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            output+="ðŸ‘· WORKERS\n"
            output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            output+="\n"
            output+="âš ï¸  No workers running!\n"
            output+="   Run: beads-workers start\n"
            output+="\n"
        else
            output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            output+="ðŸ‘· WORKERS (last 2 lines of output)\n"
            output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

            for i in $(seq 1 "$NUM_WORKERS"); do
                local log_file="$WORKER_LOG_DIR/beads_worker_$i.log"
                if [ -f "$log_file" ]; then
                    local worker_pids=($(get_worker_pids))
                    local worker_pid="${worker_pids[$((i-1))]:-???}"

                    local last_line=$(tail -1 "$log_file" 2>/dev/null)
                    local status="â“ UNKNOWN"

                    if echo "$last_line" | grep -q "Working on"; then
                        status="ðŸ”¨ WORKING"
                    elif echo "$last_line" | grep -q "Waiting"; then
                        status="â¸ï¸  WAITING"
                    elif echo "$last_line" | grep -q "Starting"; then
                        status="ðŸš€ STARTING"
                    elif echo "$last_line" | grep -q "Closing"; then
                        status="âœ… CLOSING"
                    elif echo "$last_line" | grep -q "Claiming\|Attempting"; then
                        status="ðŸŽ¯ CLAIMING"
                    fi

                    output+=$(printf "[W%-2s PID:%-6s %s]\n" "$i" "$worker_pid" "$status")

                    local recent=$(tail -2 "$log_file" 2>/dev/null | sed 's/\[Worker [0-9]* [0-9-]* [0-9:]*\] //' | sed 's/^/  /')
                    if [ -n "$recent" ]; then
                        output+="$recent\n"
                    fi
                fi
            done
        fi

        output+="\n"
        output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        output+="Press Ctrl+C to exit | Refreshing every ${refresh_interval}s\n"
        output+="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

        echo -ne "$cursor_home"
        echo -ne "$output"
    }

    # Trap exit
    trap 'echo -ne "$show_cursor"; echo ""; echo "Exiting monitor..."; exit 0' INT TERM

    # Initial setup
    echo -ne "$clear_screen$hide_cursor"

    # Main loop
    while true; do
        show_dashboard
        sleep "$refresh_interval"
    done
}

# Command: logs
cmd_logs() {
    local worker_id="$1"

    if [ -n "$worker_id" ]; then
        # Follow specific worker
        local log_file="$WORKER_LOG_DIR/beads_worker_${worker_id}.log"
        if [ ! -f "$log_file" ]; then
            log_error "No log file for worker $worker_id"
            log_info "Log file would be at: $log_file"
            exit 1
        fi
        tail -f "$log_file"
    else
        # Follow all workers
        tail -f "$WORKER_LOG_DIR"/beads_worker_*.log
    fi
}

# Command: clean
cmd_clean() {
    local count=$(ls "$WORKER_LOG_DIR"/beads_worker_*.log 2>/dev/null | wc -l)

    if [ "$count" -eq 0 ]; then
        log_info "No log files to clean"
        return
    fi

    log_info "Removing $count log files..."
    rm -f "$WORKER_LOG_DIR"/beads_worker_*.log
    log_success "Cleaned up log files"
}

# Command: help
cmd_help() {
    cat << EOF
Beads Workers v$VERSION - Concurrent task processing for beads

USAGE:
    beads-workers <command> [options]

COMMANDS:
    start           Start $NUM_WORKERS workers to process tasks
    stop            Stop all running workers
    restart         Restart all workers
    status          Show current status snapshot
    watch           Live dashboard with real-time updates
    logs [ID]       Follow worker logs (all or specific worker)
    clean           Remove all worker log files
    help            Show this help message
    version         Show version information

ENVIRONMENT VARIABLES:
    BEADS_WORKERS_COUNT       Number of workers to spawn (default: 10)
    BEADS_WORKERS_LOG_DIR     Directory for logs (default: /tmp)

EXAMPLES:
    beads-workers start              Start workers
    beads-workers watch              Monitor with live dashboard
    beads-workers logs               Follow all worker logs
    beads-workers logs 3             Follow worker 3 logs
    beads-workers stop               Stop all workers

    BEADS_WORKERS_COUNT=5 beads-workers start    Start 5 workers instead

LOG FILES:
    Workers log to: $WORKER_LOG_DIR/beads_worker_N.log

For more information, see: https://github.com/cablehead/beads
EOF
}

# Command: version
cmd_version() {
    echo "beads-workers version $VERSION"
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        restart)
            cmd_restart "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        watch)
            cmd_watch "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        clean)
            cmd_clean "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            cmd_version
            ;;
        worker-process)
            # Internal command - run worker
            worker_process "$@"
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
