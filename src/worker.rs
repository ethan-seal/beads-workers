// Worker process implementation

use crate::ipc::{RetryConfig as IpcRetryConfig, WorkerClient};
use crate::types::{OrchestratorMessage, WorkerMessage, WorkerState};
use anyhow::{Context, Result};
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use tokio::time::sleep;
use tracing::{debug, error, info, warn};

/// Worker process main loop configuration
#[derive(Debug, Clone)]
pub struct WorkerLoopConfig {
    /// Socket path to connect to orchestrator
    pub socket_path: PathBuf,
    /// Worker identifier (generated by orchestrator on first READY)
    pub worker_id: Option<String>,
    /// Connection retry configuration
    pub retry_config: IpcRetryConfig,
    /// Heartbeat interval in seconds
    pub heartbeat_interval: Duration,
    /// Whether to automatically reconnect on connection loss
    pub auto_reconnect: bool,
}

impl Default for WorkerLoopConfig {
    fn default() -> Self {
        WorkerLoopConfig {
            socket_path: PathBuf::from("/tmp/beads-workers.sock"),
            worker_id: None,
            retry_config: IpcRetryConfig::default(),
            heartbeat_interval: Duration::from_secs(30),
            auto_reconnect: true,
        }
    }
}

impl WorkerLoopConfig {
    /// Create a new worker loop configuration
    pub fn new(socket_path: PathBuf) -> Self {
        WorkerLoopConfig {
            socket_path,
            ..Default::default()
        }
    }

    /// Set the worker ID
    pub fn with_worker_id(mut self, worker_id: String) -> Self {
        self.worker_id = Some(worker_id);
        self
    }

    /// Set the retry configuration
    pub fn with_retry_config(mut self, retry_config: IpcRetryConfig) -> Self {
        self.retry_config = retry_config;
        self
    }

    /// Set the heartbeat interval
    pub fn with_heartbeat_interval(mut self, interval: Duration) -> Self {
        self.heartbeat_interval = interval;
        self
    }

    /// Set auto-reconnect behavior
    pub fn with_auto_reconnect(mut self, enabled: bool) -> Self {
        self.auto_reconnect = enabled;
        self
    }
}

/// Worker process main loop
pub struct WorkerLoop {
    /// Configuration
    config: WorkerLoopConfig,
    /// Unix socket client
    client: WorkerClient,
    /// Current worker state
    state: WorkerState,
    /// Last heartbeat time
    last_heartbeat: Option<Instant>,
}

impl WorkerLoop {
    /// Create a new worker loop
    pub fn new(config: WorkerLoopConfig) -> Self {
        let client = WorkerClient::with_retry_config(
            config.socket_path.clone(),
            config.retry_config.clone(),
        );

        WorkerLoop {
            config,
            client,
            state: WorkerState::Idle,
            last_heartbeat: None,
        }
    }

    /// Initialize the worker: connect to orchestrator and send initial READY message
    pub async fn initialize(&mut self) -> Result<String> {
        info!("Initializing worker process...");

        // Connect to orchestrator
        self.client
            .connect()
            .await
            .context("Failed to connect to orchestrator")?;

        info!(
            "Connected to orchestrator at {}",
            self.config.socket_path.display()
        );

        // Generate a temporary worker ID for initial READY message
        let temp_worker_id = self
            .config
            .worker_id
            .clone()
            .unwrap_or_else(|| format!("worker-{}", std::process::id()));

        // Send READY message
        let ready_msg = WorkerMessage::ready(temp_worker_id.clone());
        self.client
            .send_message(ready_msg)
            .await
            .context("Failed to send READY message")?;

        info!("Sent initial READY message with worker_id: {}", temp_worker_id);

        // Wait for first response to get assigned worker ID
        let response = self
            .client
            .receive_message()
            .await
            .context("Failed to receive initial response from orchestrator")?;

        // Extract worker ID from response
        let assigned_worker_id = response.worker_id().to_string();
        self.client.set_worker_id(assigned_worker_id.clone());
        self.config.worker_id = Some(assigned_worker_id.clone());

        info!("Worker initialized with ID: {}", assigned_worker_id);

        // Process the first message
        self.handle_message(response).await?;

        Ok(assigned_worker_id)
    }

    /// Run the main worker loop
    pub async fn run(&mut self) -> Result<()> {
        info!("Starting worker main loop");
        self.last_heartbeat = Some(Instant::now());

        loop {
            // Check if we need to send a heartbeat
            if self.should_send_heartbeat() {
                if let Err(e) = self.send_heartbeat().await {
                    error!("Failed to send heartbeat: {}", e);
                    if self.config.auto_reconnect {
                        if let Err(e) = self.reconnect_and_continue().await {
                            error!("Failed to reconnect: {}", e);
                            return Err(e);
                        }
                        continue;
                    } else {
                        return Err(e);
                    }
                }
            }

            // When idle, send READY message
            if self.state == WorkerState::Idle {
                let worker_id = self
                    .config
                    .worker_id
                    .clone()
                    .expect("Worker ID should be set after initialization");

                let ready_msg = WorkerMessage::ready(worker_id);

                if let Err(e) = self.client.send_message(ready_msg).await {
                    error!("Failed to send READY message: {}", e);
                    if self.config.auto_reconnect {
                        if let Err(e) = self.reconnect_and_continue().await {
                            error!("Failed to reconnect: {}", e);
                            return Err(e);
                        }
                        continue;
                    } else {
                        return Err(e.into());
                    }
                }

                debug!("Sent READY message, waiting for orchestrator response");
            }

            // Wait for message from orchestrator
            match self.client.receive_message().await {
                Ok(message) => {
                    debug!("Received message: {:?}", message);

                    // Handle the message
                    if let Err(e) = self.handle_message(message).await {
                        error!("Error handling message: {}", e);
                        // Continue processing unless it's a shutdown
                        if matches!(self.state, WorkerState::ShuttingDown) {
                            return Err(e);
                        }
                    }

                    // Check if we should exit
                    if self.state == WorkerState::ShuttingDown {
                        info!("Worker shutting down");
                        break;
                    }
                }
                Err(e) => {
                    error!("Failed to receive message: {}", e);
                    if self.config.auto_reconnect {
                        if let Err(e) = self.reconnect_and_continue().await {
                            error!("Failed to reconnect: {}", e);
                            return Err(e);
                        }
                    } else {
                        return Err(e.into());
                    }
                }
            }
        }

        Ok(())
    }

    /// Handle a message from the orchestrator
    async fn handle_message(&mut self, message: OrchestratorMessage) -> Result<()> {
        match message {
            OrchestratorMessage::Task {
                issue_id,
                priority,
                title,
                ..
            } => {
                info!(
                    "Received TASK: {} (priority: {}) - {}",
                    issue_id, priority, title
                );
                self.handle_task(issue_id, title).await?;
            }

            OrchestratorMessage::Wait { wait_seconds, .. } => {
                info!("Received WAIT: sleep for {} seconds", wait_seconds);
                self.state = WorkerState::Waiting;
                sleep(Duration::from_secs(wait_seconds as u64)).await;
                self.state = WorkerState::Idle;
            }

            OrchestratorMessage::Shutdown { reason, .. } => {
                info!("Received SHUTDOWN: {:?}", reason);
                self.state = WorkerState::ShuttingDown;
            }
        }

        Ok(())
    }

    /// Execute a task using bd CLI
    async fn handle_task(&mut self, issue_id: String, title: String) -> Result<()> {
        self.state = WorkerState::Working;
        let start_time = Instant::now();

        info!("Executing task: {} - {}", issue_id, title);

        let worker_id = self
            .config
            .worker_id
            .clone()
            .expect("Worker ID should be set");

        // Execute the task using bd CLI
        let result = self.execute_bd_task(&issue_id).await;

        let duration_ms = start_time.elapsed().as_millis() as u64;

        // Send result back to orchestrator
        let response_msg = match result {
            Ok(()) => {
                info!("Task {} completed successfully in {}ms", issue_id, duration_ms);
                WorkerMessage::done(worker_id, issue_id, duration_ms)
            }
            Err(e) => {
                error!("Task {} failed after {}ms: {}", issue_id, duration_ms, e);
                WorkerMessage::failed(worker_id, issue_id, e.to_string(), duration_ms)
            }
        };

        self.client
            .send_message(response_msg)
            .await
            .context("Failed to send task result")?;

        self.state = WorkerState::Idle;
        Ok(())
    }

    /// Execute a task using the bd CLI
    async fn execute_bd_task(&self, issue_id: &str) -> Result<()> {
        // Execute: bd update <issue_id> --status=in_progress
        debug!("Setting task {} to in_progress", issue_id);
        let status = Command::new("bd")
            .args(["update", issue_id, "--status=in_progress"])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .status()
            .context("Failed to execute bd update command")?;

        if !status.success() {
            anyhow::bail!("Failed to set task status to in_progress");
        }

        // Get task details
        debug!("Fetching task details for {}", issue_id);
        let output = Command::new("bd")
            .args(["show", issue_id])
            .output()
            .context("Failed to execute bd show command")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("Failed to fetch task details: {}", stderr);
        }

        // TODO: Parse task details and execute the actual work
        // For now, this is a placeholder that demonstrates the workflow

        // Simulate some work
        info!("Processing task: {}", issue_id);
        tokio::time::sleep(Duration::from_secs(2)).await;

        // Close the task
        debug!("Closing task {}", issue_id);
        let status = Command::new("bd")
            .args(["close", issue_id])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .status()
            .context("Failed to execute bd close command")?;

        if !status.success() {
            anyhow::bail!("Failed to close task");
        }

        Ok(())
    }

    /// Check if we should send a heartbeat
    fn should_send_heartbeat(&self) -> bool {
        if let Some(last_heartbeat) = self.last_heartbeat {
            last_heartbeat.elapsed() >= self.config.heartbeat_interval
        } else {
            false
        }
    }

    /// Send a heartbeat message to the orchestrator
    async fn send_heartbeat(&mut self) -> Result<()> {
        let worker_id = self
            .config
            .worker_id
            .clone()
            .expect("Worker ID should be set");

        let heartbeat_msg = WorkerMessage::heartbeat(worker_id);
        self.client
            .send_message(heartbeat_msg)
            .await
            .context("Failed to send heartbeat")?;

        self.last_heartbeat = Some(Instant::now());
        debug!("Sent heartbeat");
        Ok(())
    }

    /// Reconnect to orchestrator and continue operation
    async fn reconnect_and_continue(&mut self) -> Result<()> {
        warn!("Connection lost, attempting to reconnect...");
        self.client
            .reconnect()
            .await
            .context("Failed to reconnect to orchestrator")?;

        info!("Reconnected to orchestrator");

        // Send READY message to re-register
        let worker_id = self
            .config
            .worker_id
            .clone()
            .expect("Worker ID should be set");

        let ready_msg = WorkerMessage::ready(worker_id);
        self.client
            .send_message(ready_msg)
            .await
            .context("Failed to send READY message after reconnection")?;

        self.state = WorkerState::Idle;
        info!("Re-registered with orchestrator");
        Ok(())
    }

    /// Disconnect from the orchestrator
    pub async fn disconnect(&mut self) {
        info!("Disconnecting from orchestrator");
        self.client.disconnect().await;
        self.state = WorkerState::Disconnected;
    }

    /// Get the current worker ID
    pub fn worker_id(&self) -> Option<&str> {
        self.config.worker_id.as_deref()
    }

    /// Get the current worker state
    pub fn state(&self) -> WorkerState {
        self.state
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_worker_loop_config_default() {
        let config = WorkerLoopConfig::default();
        assert_eq!(
            config.socket_path,
            PathBuf::from("/tmp/beads-workers.sock")
        );
        assert_eq!(config.worker_id, None);
        assert_eq!(config.heartbeat_interval, Duration::from_secs(30));
        assert!(config.auto_reconnect);
    }

    #[test]
    fn test_worker_loop_config_builder() {
        let config = WorkerLoopConfig::new(PathBuf::from("/tmp/test.sock"))
            .with_worker_id("W1".to_string())
            .with_heartbeat_interval(Duration::from_secs(60))
            .with_auto_reconnect(false);

        assert_eq!(config.socket_path, PathBuf::from("/tmp/test.sock"));
        assert_eq!(config.worker_id, Some("W1".to_string()));
        assert_eq!(config.heartbeat_interval, Duration::from_secs(60));
        assert!(!config.auto_reconnect);
    }

    #[test]
    fn test_worker_loop_creation() {
        let config = WorkerLoopConfig::new(PathBuf::from("/tmp/test.sock"));
        let worker = WorkerLoop::new(config);

        assert_eq!(worker.state, WorkerState::Idle);
        assert_eq!(worker.worker_id(), None);
        assert!(worker.last_heartbeat.is_none());
    }

    #[test]
    fn test_should_send_heartbeat() {
        let config =
            WorkerLoopConfig::new(PathBuf::from("/tmp/test.sock"))
                .with_heartbeat_interval(Duration::from_secs(1));

        let mut worker = WorkerLoop::new(config);

        // No heartbeat sent yet
        assert!(!worker.should_send_heartbeat());

        // Set last heartbeat to 2 seconds ago
        worker.last_heartbeat = Some(Instant::now() - Duration::from_secs(2));

        // Should send heartbeat
        assert!(worker.should_send_heartbeat());
    }
}
